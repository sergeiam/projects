<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
		
			class GrassBlade
			{
				constructor(x, y)
				{
					this.material = new THREE.ShaderMaterial({
						uniforms: {
							bending: { type:"vec2", value: new THREE.Vector2(0.0, 0.0) }
						},
						vertexShader: [
							"uniform vec2 bending;",
							"void main() {",
							"	vec3 pos = position;",
							"	pos.x += bending.x*max(0.0, pos.y);",
							"	pos.z += bending.y*max(0.0, pos.y);",
							"	vec4 modelViewPosition = modelViewMatrix * vec4(pos, 1.0);",
							"	gl_Position = projectionMatrix * modelViewPosition;",
							"}"
						].join('\n'),
						fragmentShader: [
							"void main() {",
							"	gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);",
							"}"
						].join('\n')
					});
					this.mesh = new THREE.Mesh( new THREE.BoxGeometry( 0.2, 1.0, 0.2 ), this.material );
					this.mesh.position.x = x;
					this.mesh.position.z = y;
					scene.add( this.mesh );
				}
				set_bending(x,y)
				{
					this.material.uniforms.bending.value.x = x;
					this.material.uniforms.bending.value.y = y;
				}
				interact(x,z,vx,vz,R)
				{
					var bx = this.mesh.position.x;
					var bz = this.mesh.position.z;
					var dist = Math.sqrt((x - bx)*(x - bx) + (z - bz)*(z - bz));
					if(dist < 1.0)
					{
						this.set_bending(vx, vz);
					}
					this.update();
				}
				update()
				{
					var bx = this.material.uniforms.bending.value.x;
					var by = this.material.uniforms.bending.value.y;
					
					bx *= 0.95;
					by *= 0.95;
					
					this.material.uniforms.bending.value.x = bx;
					this.material.uniforms.bending.value.y = by;
				}
			}
			
			var grass_field = []
			for( var y=0; y<12; y += 1 )
			{
				for( var x=0; x<12; x += 1 )
				{
					grass_field.push(new GrassBlade(x * 1.0, y * 1.0));
				}
			}
			
			camera.position.z = 13.0;
			camera.position.y = 4.0;
			camera.position.x = 4.0;
			camera.rotation.x = -0.8;
			
			var cursor = new THREE.Mesh( new THREE.CylinderGeometry(1.0, 1.0, 1.0, 8.0), new THREE.MeshBasicMaterial());
			scene.add(cursor);
			
			cursor.setPosition = function(x,z)
			{
				this.velocity = new THREE.Vector2(x - this.position.x, z - this.position.z);
				this.position.x = x;
				this.position.z = z;
			};
			
			var mouse2d = new THREE.Vector3(0.0, 0.0, -1.0);
			document.addEventListener('mousemove', onMouseMove, false);
			
			function onMouseMove(event)
			{
				mouse2d.x = event.clientX / window.innerWidth * 2.0 - 1.0;
				mouse2d.y = 1.0 - event.clientY / window.innerHeight * 2.0;
			}

			var animate = function ()
			{
				renderer.render( scene, camera );
				
				var mouse3d = mouse2d.clone().unproject( camera );
				//console.log( "mouse3d.x = " + mouse3d.x );
				var ray_dir = mouse3d.clone().sub( camera.position );
				//console.log( "rx = " + ray_dir.x + " ry = " + ray_dir.y + " rz = " + ray_dir.z );
				
				if( ray_dir.y < 0.001 )
				{
					var ray_hit = new THREE.Vector3();
					var coef = (camera.position.y / -ray_dir.y);
				
					ray_dir.multiplyScalar( coef );
					
					var ray_hit = ray_dir.clone().add(camera.position);
					
					//console.log( "x = " + ray_hit.x + " z = " + ray_hit.z );
					
					cursor.setPosition(ray_hit.x, ray_hit.z);
					
					for( var i=0; i<grass_field.length; ++i )
					{
						grass_field[i].interact(cursor.position.x, cursor.position.z, cursor.velocity.x, cursor.velocity.y, 1.0);
					}
				}
				requestAnimationFrame( animate );
			};

			animate();
		</script>
	</body>
</html>